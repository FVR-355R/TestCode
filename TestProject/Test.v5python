{"mode":"Text","textContent":"# ------------------------------------------\n# \n# \tProject:  PYTHON RedSmallStateScrimmage1\n#\tAuthor:\n#\tCreated:\n#\tConfiguration:\n# \n# ------------------------------------------\n\n# Based on C++ version located here:\n# https://raw.githubusercontent.com/FVR-Endermen/355R-2019-2020/master/preStateScrimmage1/RedSmallStateScrimmage1/src/main.cpp\n\n\n# Library imports\nfrom vex import *\n\n# global constants \n\nwheel_radius_in_inches = 2.0\nPi = 3.14159267\n\n\"\"\"\n something to measure -- its the diagonal distance between wheels\n through the CENTER of the robot.  DIAMETER of the robot\n Note this is something we end up tuning -- it would probably be\n exactly the diagonal for ideal wheels, but the mecanums slip a bit\n Currently calibrate by what number we need for a 180 degree turn to\n actually turn 180 degrees!\n\"\"\"\ndiag_wheel_base_in_inches = 22.0\n\nstop_feeder = True\n\n \n\n\n# Begin project code\n\ndef pre_autonomous():\n    # actions to do when the program starts\n    brain.screen.clear_screen()\n    brain.screen.print(\"pre auton code\")\n    wait(1, SECONDS)\n\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"autonomous code\")\n    # place automonous code here\n\n#  Get more of the feeder lower\n    #LiftStacker(0.1,true);\n\n    feeder_action(55,True);\n\n\n    # These were a test -- don't use!\n\n    # strafe(20.0,50)\n    # strafe (-20.0,50)\n\n# the howfast numbers used to be RPM, now apparently its percent\n\n    move_forward(15.0,75)\n    move_forward(2.0,65)\n    move_forward(29.0,25)\n\n    #vex.wait(500)\n\n    #feeder_action(46,True)\n    # stop feeder before turning\n\n    #lift_stacker(0.1, False)\n\n    feeder_action(20,True)\n\n    # rotate_clockwise(210.0)\n    rotate_clockwise(180.0,85)\n\n    move_forward(25.5, 100)\n\n    rotate_clockwise(-45.5, 65)\n\n    # vex.wait(1000)\n    # feeder_action(50, True)\n    move_forward(16.3, 100)\n\n    feeder_action(0,false)\n\n    move_forward(7.0,35)\n\n    move_forward(-0.5,35)\n\n    lift_stacker(3.75,true)\n\n    move_forward(-20.0,20)\n\n    # old place steps\n    # lift_stacker(2.0,True)\n\n    # feeder_action(40,False)\n    # lift_stacker(1.0,False)\n\n    # With new feeder\n\n \"\"\"   \n\n    lift_stacker(1.0, True)\n    move_forward(-1.0,20)\n    lift_stacker(0.5,True)\n    move_forward(-1.0,20)\n    lift_stacker(0.5,True)\n    move_forward(-1.0,20)\n    lift_stacker(0.1,True)\n    move_forward(-1.0,20)\n    lift_stacker(0.1,True)\n    move_forward(-1.0,20)\n\n    #lift_stacker(0.5,True)\n    #lift_stacker(0.5,True)\n    \n    lift_stacker(0.8,True)\n    # feeder_action(10,False)\n    lift_stacker(1.15,True)\n\n    # feeder_action(20,False)\n    # vex.wait(500)\n\n    feeder_action(40,False)\n    lift_stacker(2.2.False)\n    # lift_stacker(-2.2,True)\n    feeder_action(0,True)\n\n\"\"\"\n\n\ndef user_control():\n\n    #Deadband stops the motors when Axis values are close to zero.\n    deadband = 5\n\n    #How fast the feeder motors will spin\n    feeder_speed = 50\n    lifter_speed = 15\n\n    brain.screen.clear_screen()\n    # place driver control in this while loop\n    while True:\n\n        # SIMPLE TANK DRIVE\n\n        # Get the velocity percentage of the left motor. (Axis 3)\n        left_motor_speed = controller_1.axis3.position()\n        # Get the velocity percentage of the right motor. (Axis 2)\n        right_motor_speed = controller_1.axis2.position()\n\n        # what is the state of button L1\n        l1_down = controller_1.buttonL1.pressing()\n\n        # what is the state of button R1\n        r1_down = controller_1.buttonR1.pressing()\n\n        # what is the state of button L2\n        l2_down = controller_1.buttonL2.pressing()\n\n        # what is the state of button R2\n        r2_down = controller_1.buttonR2.pressing()\n\n        up_arrow_pushed = controller_1.buttonUp.pressing()\n        down_arrow_pushed = controller_1.buttonDown.pressing()\n\n        # Set the speed of the left motor. If the value is less than the deadband,\n        # set it to zero.\n\n        if (abs(left_motor_speed) < deadband):\n            # set the speed to zero\n            left_front_motor.set_velocity(0, PERCENT)\n            left_back_motor.set_velocity(0, PERCENT)\n\n        else:\n            # set to left_motor_speed\n            left_front_motor.set_velocity(left_motor_speed, PERCENT)\n            left_back_motor.set_velocity(left_motor_speed, PERCENT)\n\n        # Set the speed of the right motor. If the value is less than the deadband,\n        # set it to zero.\n\n        if (abs(right_motor_speed) < deadband):\n            # set the speed to zero\n            right_front_motor.set_velocity(0, PERCENT)\n            right_back_motor.set_velocity(0, PERCENT)\n\n        else:\n            # set to right_motor_speed\n            right_front_motor.set_velocity(right_motor_speed, PERCENT)\n            right_back_motor.set_velocity(right_motor_speed, PERCENT)\n\n        # spin both motors in the forward direction\n\n        left_front_motor.spin(forward)\n        right_front_motor.spin(forward)\n        left_back_motor.spin(forward)\n        right_back(motor.spin(forward)\n\n\n        # Feeder L1 and R1\n\n        # stop motors if nobody is pressed or if BOTH are pressed\n\n        if ( (not(l1_down) && not(r1_down))  ||  (l1_down && r1_down) ):\n            feeder_left_motor.set_velocity(0,PERCENT)\n            feeder_right_motor.set_velocity(0,PERCENT)\n        else if (l1_down && not(r1_down)):\n            feeder_left_motor.set_velocity(feeder_speed, PERCENT)\n            feeder_right_motor.set_velocity(feeder_speed, PERCENT)\n        else if (r1_down && not(l1_down)):\n            feeder_left_motor.set_velocity(-feeder_speed, PERCENT)\n            feeder_right_motor.set_velocity(-feeder_speed, PERCENT)\n        else: \n            feeder_left_motor.set_velocity(0,PERCENT)\n            feeder_right_motor.set_velocity(0,PERCENT) \n\n        # now that they are set, spin the feeder motors\n\n        feeder_left_motor.spin(FORWARD)\n        feeder_right_motor.spin(FORWARD)\n\n\n        # similar logic for the lift motor\n\n\n        if ( (not(l2_down) && not(r2_down))  ||  (l2_down && r2_down) ):\n            lift_motor.set_velocity(0,PERCENT)\n        else if (l2_down && not(r2_down)):\n            lift_motor.set_velocity(feeder_speed, PERCENT)\n        else if (r2_down && not(l2_down)):\n            lift_motor.set_velocity(-feeder_speed, PERCENT)\n        else: \n            lift_motor.set_velocity(0,PERCENT)\n\n        # now that it is set, spin the lift motor\n\n        lift_motor.spin(FORWARD)\n\n\n        # up and down motors\n\n\n       if ( (not(up_arrow_pushed) && not(down_arrow_pushed))  ||  (up_arrow_pushed && down_arrow_pushed) ):\n            rack_n_pinion_motor.set_velocity(0,PERCENT)\n        # up arrow tilts it up\n        else if (up_arrow_pushed && not(down_arrow_pushed)):\n            rack_n_pinion_motor.set_velocity(lifter_speed, PERCENT)\n            # try and force the feeder down as we lift up\n            lift_motor.set_velocity(feeder_speed, PERCENT)\n        # down arrow tilts it down\n        else if (down_arrow_pushed && not(up_arrow_pushed)):\n            rack_n_pinion_motor.set_velocity(-lifter_speed, PERCENT)\n        else: \n            rack_n_pinion_motor.set_velocity(0,PERCENT)\n\n        # now that it is set, spin the lift motor\n\n        rack_n_pinion_motor.spin(FORWARD)\n        lift_motor.spin(FORWARD)\n\n        wait(20, MSEC)\n\n\n\n\n# create competition instance\ncomp = Competition(user_control, autonomous)\npre_autonomous()\n\n\ndef lift_stacker(n_rotations=0, direction=True):\n    rack_and_pinion_angle = n_rotations * 360.0\n    if (direction):\n        # Get lift motor(s) pushing down\n        lift_motor.set_velocity(20.0, PERCENT)\n        lift_motor.spin(FORWARD)\n        # Then push up rack\n        rack_n_pinion_motor.spin_to_position(rack_and_pinion_angle, DEGREES, True)\n        # Stop lift motor\n        lift_motor.set_velocity(0.0, PERCENT)\n        lift_motor.spin(FORWARD)\n    else:\n        rack_n_pinion_motor.spin_to_position(-rack_and_pinion_angle, DEGREES, True)\n\n    rack_n_pinion_motor.set_position(0,DEGREES)\n\n\n\ndef feeder_action(feeder_speed=0, direction=True):\n    if (direction):\n        feeder_left_motor.set_velocity(feeder_speed,PERCENT)\n        feeder_right_motor.set_velocity(feeder_speed,PERCENT)\n        feeder_left_motor.spin(FORWARD)\n        feeder_right_motor.spin(FORWARD)\n    else:\n        feeder_left_motor.set_velocity(-feeder_speed,PERCENT)\n        feeder_right_motor.set_velocity(-feeder_speed,PERCENT)\n        feeder_left_motor.spin(FORWARD)\n        feeder_right_motor.spin(FORWARD)  \n\n\n\n# Function to move forward, howfar is in INCHES\n\ndef move_forward(howfar, howfast):\n\n# need to convert inches to number of rotations and then to degrees\n# number of rotations is how many circumferences the argument howfar is\n\n    n_rotations = howfar / Pi / wheel_radius_in_inches / 2.0\n    rotation_degrees = n_rotations * 360.0\n\n# motion speed\n\n# in v1.01 this was in rpm -- apparently in the python api this is now PERCENT\n    motor_velocity = howfast\n\n\"\"\"\nWhat this is doing:\nspinToPosition tells it to spin the wheel until it hits the requested position\nthe second argument is \"degrees\" which is a constant that tells it the angle is\nin -- believe it or not -- degrees\nthe last argument tells it to wait or not before moving to the next one.\nThe default is true.  This means if we leave the default with the four statements\nbelow, it will rotate the first wheel, then the next, then the next, and the last\nIf we set false, it will get the motor started, then move on to the next statement.\nSo here we set the first 3 to false, but the last one to true.  This should\nmove all 4 at essentially the same time, but wait until the last one is done.\nIt should move the drivetrain as a whole here.\n\"\"\"\n\n# it will be interesting if this still works -- \n    left_front_motor.spin_to_position(rotation_degrees, DEGREES, motorvelocity, PERCENT, False) # false keeps spinning\n    right_front_motor.spin_to_position(rotation_degrees, DEGREES, motorvelocity, PERCENT, False) # also False\n    left_back_motor.spin_to_position(rotation_degrees, DEGREES, motorvelocity, PERCENT, False) # also False\n    right_back_motor.spin_to_position(rotation_degrees, DEGREES, motorvelocity, PERCENT, True) # now True to stop\n\n# attempt to re-set motor encoder \n\n    left_front_motor.set_position(0,DEGREES)\n    right_front_motor.set_position(0,DEGREES)\n    left_back_motor.set_position(0,DEGREES)\n    right_back_motor.set_position(0,DEGREES)\n\n\n\n\n\n\n# Function to strafe (comes from MoveForward), howfar is in INCHES\n# Positive is to the right, negative to the left\n\ndef strafe(howfar=0, howfast=0):\n\n# need to convert inches to number of rotations and then to degrees \n# number of rotations is how many circumferences the argument howfar is\n\n    n_rotations = howfar / Pi / wheel_radius_in_inches / 2.0\n    rotation_degrees = n_rotations * 360.0\n\n#  motion speed\n\n    motor_velocity = howfast\n\n\"\"\"\n What this is doing:\n spinToPosition tells it to spin the wheel until it hits the requested position\n the second argument is \"degrees\" which is a constant that tells it the angle is\n in -- believe it or not -- degrees\n the last argument tells it to wait or not before moving to the next one.\n The default is true.  This means if we leave the default with the four statements\n below, it will rotate the first wheel, then the next, then the next, and the last\n If we set false, it will get the motor started, then move on to the next statement.\n So here we set the first 3 to false, but the last one to true.  This should\n move all 4 at essentially the same time, but wait until the last one is done.\n It should move the drivetrain as a whole here.\n\n Now modified this to strafe -- which is moving left to right.  To do that\n make the front and back wheels move in opposite directions.Brain\n\n Move right =\n  RightFrontMotor reverse\n  RightBackMotor  forward\n  LeftFrontMotor  forward\n  LeftBackMotor   reverse\n\n  Changing sign of nRotations to do this\n\"\"\"\n\n    left_front_motor.spin_to_position(rotation_degrees, DEGREES, motor_velocity, PERCENT, False) # False keeps spinning\n    right_front_motor.spin_to_position(-rotation_degrees, DEGREES, motor_velocity, PERCENT, False) # also False\n    left_back_motor.spin_to_position(-rotation_degrees, DEGREES, motor_velocity, PERCENT, False) # also False\n    right_back_motor.spin_to_position(rotation_degrees, DEGREES, motor_velocity, PERCENT, True) # now True\n\n # attempt to re-set motor encoder \n\n    left_front_motor.set_position(0,DEGREES)\n    right_front_motor.set_position(0,DEGREES)\n    left_back_motor.set_position(0,DEGREES)\n    right_back_motor.set_position(0,DEGREES)\n\n\n# Function to rotate the robot clockwise, howfar is in DEGREES\n\ndef rotate_clockwise(howfar=0, howfast=0):\n\n\"\"\"\n The idea is to rotate the motors enough to have them travel along\n the circumference of the circle drawn by the wheels around the\n center of the robot.\n\"\"\"\n\n    robot_circumference = Pi * diag_wheel_base_in_inches\n\n# now we convert howfar into a number of ROBOT rotations\n\n    robot_rotations = howfar / 360.0\n\n# how many wheel rotations is one robot rotation\n\n    wheel_circumference = Pi * wheel_radius_in_inches * 2.0\n\n# how many times the wheel goes around to travel the circumference (one robot rotation)\n\n    wheel_rotations_in_robot_rotation = robot_circumference / wheel)circumference\n\n# to turn clockwise, left wheels drive forward, right wheels drive backward\n\n    wheel_rotations = robot_rotations * wheel_rotations_in_robot_rotation\n\n# and back to degrees\n\n    left_wheel_degrees = wheel_rotations * 360.0\n    right_wheel_degrees = 0.0 - left_wheel_degrees\n\n# now we drive!\n\n    left_front_motor.spin_to_position(left_wheel_degrees,DEGREES, False)\n    left_back_motor.spin_to_position(left_wheel_degrees,DEGREES, False)\n\n    right_front_motor.spin_to_position(right_wheel_degrees, DEGREES, False)\n    right_back_motor.spin_to_position(right_wheel_degrees, DEGREES, True)\n\n\n# attempt to re-set motor encoder \n\n    left_front_motor.set_position(0,DEGREES)\n    right_front_motor.set_position(0,DEGREES)\n    left_back_motor.set_position(0,DEGREES)\n    right_back_motor.set_position(0,DEGREES)","textLanguage":"python","rconfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"}},{"port":[5],"name":"left_front_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}},{"port":[6],"name":"left_back_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}},{"port":[9],"name":"right_front_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[20],"name":"right_back_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[10],"name":"feeder_right_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[3],"name":"feeder_left_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}},{"port":[1],"name":"lift_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[8],"name":"rack_n_pinion_motor","customName":true,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}}],"slot":0,"platform":"V5","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":""}